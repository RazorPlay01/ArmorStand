# 渲染调度过程

为了最大地实现实例化绘制，减少数据拷贝次数，需要进行渲染的调度。

## 基本概念

### 渲染图元 (Render primitive)

在 ArmorStand 的语境下，图元指的不是图形学上一个线、三角形一类的图元，而是 glTF 定义中的图元，具有以下特点：

- 由若干个图形学上的图元组成（有顶点缓冲区和可选的索引缓冲区）
- 有且只有一个材质

在 ArmorStand 中，对于任意的模型，渲染的基本单位是图元；因此实例化渲染调度的基本单位也是图元。

渲染效果也是以图元为单位的：

- 骨骼蒙皮
- 变形目标

### 渲染场景 (Render scene)

渲染场景是模型数据加载到内存显存后的结构，包含模型渲染所需要的*不变*的数据，例如图元数据、节点数据（只包含初始变换、层次结构）。

### 渲染实例 (Render instance)

渲染实例是绑定到某个渲染场景中，包含可变的数据的对象，其本身持有对渲染场景的引用。

渲染实例中存储了：

- 每个节点的实时变换
- 骨骼蒙皮的变换数据
- 变形目标的目标索引和权重

ArmorStand 采用分离渲染场景和渲染实例的设计，使得多个玩家使用相同的模型时，只需要加载一次模型数据即可，并且为实例化渲染等优化技术提供了可能性。

## 以前的设计架构

之前采用 RenderTask 的设计架构，每次安排绘制时更新模型数据，并产生一个渲染任务，发送到任务调度器。

任务调度器按不同的渲染图元为渲染任务分组，在所有实体处理完后，以分组为单位进行实例化渲染。由于是以图元为条件进行分组的，因此每个分组的中所有渲染任务的渲染图元都是相同的。

每次渲染一个分组时，渲染器会将渲染任务中的所有复杂数据（骨骼蒙皮矩阵、变形目标索引和权重）合并复制到大缓冲区，并上传到 GPU。这就带来了每帧的数据上传开销。

## 目前的设计架构

由于新版（1.21.6）的 Blaze3D 添加了 GPU 缓存持久化映射的支持，因此渲染架构可以进行更进一步的优化。

原先的瓶颈在数据合并上传过程中，因此新架构需要减去这些开销。

具体的设计思路是直接在 RenderInstance 中进行分组，而不是推迟到渲染调度时。创建 RenderInstance 时，所有复杂数据的都预先按不同的渲染基元分组，同一组的数据直接就分配在一个大的缓冲区内，编辑时直接使用内存映射的方式修改显存中的数据。

这样的设计也带来了几个问题：

- 不是每一帧都会渲染所有的 RenderInstance。
- 如果一帧内需要绘制 RenderInstance 一次以上，最后一次渲染的数据会覆盖以前的数据，导致实际上只有最后一次生效。

针对第一个问题，设置一个额外的缓冲区，存储目前实例化批次中需要绘制的对象索引即可。

针对第二个问题，考虑到实际上一帧内渲染一个物体两次的情况很少出现，可以只对最后一次渲染做实例化绘制，前面的渲染不进行实例化绘制即可。

## 渲染调度架构

TODO